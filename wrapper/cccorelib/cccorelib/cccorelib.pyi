from cccorelib import ScalarType, PointCoordinateType
from typing import TypeVar, Generic, overload, NewType, Callable, Optional
from abc import ABC, abstractmethod
import numpy

T = TypeVar('T')
StringType = TypeVar('StringType')

class Vector2Tpl(Generic[T]):
    x: T
    y: T

    @overload
    def __init__(self) -> None: ...

    @overload
    def __init__(self, other: 'Vector2Tpl[T]') -> None: ...

    @overload
    def __init__(self, x: T, y: T) -> None: ...

    def norm2(self) -> T: ...

    def norm(self) -> T: ...

    def normalize(self) -> None: ...

    def dot(self, v: 'Vector2Tpl[T]') -> T: ...

    def cross(self, v: 'Vector2Tpl[T]') -> T: ...

    def __iadd__(self, other: 'Vector2Tpl[T]') -> None: ...

    def __isub__(self, other: 'Vector2Tpl[T]') -> None: ...

    def __itruediv__(self, other: 'Vector2Tpl[T]') -> None: ...

    def __imul__(self, other: 'Vector2Tpl[T]') -> None: ...

    def __add__(self, other: 'Vector2Tpl[T]') -> 'Vector2Tpl[T]': ...

    def __sub__(self, other: 'Vector2Tpl[T]') -> 'Vector2Tpl[T]': ...

    def __truediv__(self, other: 'Vector2Tpl[T]') -> 'Vector2Tpl[T]': ...

    def __mul__(self, other: 'Vector2Tpl[T]') -> 'Vector2Tpl[T]': ...

    def __getitem__(self, item: int) -> T: ...

    def __setitem__(self, key: int, value: T) -> None: ...

    def __repr__(self) -> str: ...


class CCVector2(Vector2Tpl[PointCoordinateType]): ...


class CCVector2d(Vector2Tpl[float]): ...


class Vector3Tpl(Generic[T]):
    x: T
    y: T
    z: T

    @overload
    def __init__(self) -> None: ...

    @overload
    def __init__(self, other: 'Vector3Tpl[T]') -> None: ...

    @overload
    def __init__(self, x: T, y: T, z: T) -> None: ...

    def norm2(self) -> T: ...

    def norm(self) -> T: ...

    def normalize(self) -> None: ...

    def dot(self, v: 'Vector3Tpl[T]') -> T: ...

    def cross(self, v: 'Vector3Tpl[T]') -> T: ...

    def __iadd__(self, other: 'Vector3Tpl[T]') -> None: ...

    def __isub__(self, other: 'Vector3Tpl[T]') -> None: ...

    def __itruediv__(self, other: 'Vector3Tpl[T]') -> None: ...

    def __imul__(self, other: 'Vector3Tpl[T]') -> None: ...

    def __add__(self, other: 'Vector3Tpl[T]') -> 'Vector3Tpl[T]': ...

    def __sub__(self, other: 'Vector3Tpl[T]') -> 'Vector3Tpl[T]': ...

    def __truediv__(self, other: 'Vector3Tpl[T]') -> 'Vector3Tpl[T]': ...

    def __mul__(self, other: 'Vector3Tpl[T]') -> 'Vector3Tpl[T]': ...

    def __getitem__(self, item: int) -> T: ...

    def __setitem__(self, key: int, value: T) -> None: ...

    def __repr__(self) -> str: ...


class CCVector3(Vector3Tpl[PointCoordinateType]): ...


class CCVector3d(Vector3Tpl[float]): ...


# CCMath

def LessThanEpsilon(x: float) -> bool: ...


def GreaterThanEpsilon(x: float) -> bool: ...


def RadiansToDegrees(x: float) -> float: ...


def DegreesToRadians(x: float) -> float: ...


# CCConst

SQRT_3: float
ZERO_TOLERANCE_D: float
ZERO_TOLERANCE_SCALAR: ScalarType
ZERO_TOLERANCE_POINT_COORDINATE: ScalarType
PC_ONE: PointCoordinateType
PC_NAN: PointCoordinateType
NAN_VALUE: ScalarType

# Technically uchars
POINT_VISIBLE: int
POINT_HIDDEN: int
POINT_OUT_OF_RANGE: int
POINT_OUT_OF_FOV: int


# TODO enums CHAMFER_DISTANCE_TYPE
# TODO enums LOCAL_MODEL_TYPES
# TODO CC_LOCAL_MODEL_MIN_SIZE


# BoundingBox

class BoundingBox:
    @overload
    def __init__(self) -> None: ...

    @overload
    def __init__(self, minCorner: CCVector3, maxCorner: CCVector3) -> None: ...

    def __add__(self, other: 'BoundingBox') -> None: ...

    @overload
    def __iadd__(self, other: 'BoundingBox') -> None: ...

    @overload
    def __iadd__(self, other: CCVector3) -> None: ...

    def __isub__(self, other: CCVector3) -> None: ...

    def __imul__(self, other: PointCoordinateType) -> None: ...

    # TODO __imul__ squarematrix

    def clear(self) -> None: ...

    def add(self, P: CCVector3) -> None: ...

    def minCorner(self) -> CCVector3: ...

    def maxCorner(self) -> CCVector3: ...

    def getCenter(self) -> CCVector3: ...

    def getDiagVec(self) -> CCVector3: ...

    def getDiagNorm(self) -> PointCoordinateType: ...

    def getDiagNormd(self) -> float: ...

    def getMinBoxDim(self) -> PointCoordinateType: ...

    def getMaxBoxDim(self) -> PointCoordinateType: ...

    def computeVolume(self) -> float: ...

    def setValidity(self, state: bool) -> None: ...

    def isValid(self) -> bool: ...

    def minDistTo(self, bbox: 'BoundingBox') -> PointCoordinateType: ...

    def contains(self, P: CCVector3) -> bool: ...

# ScalarField

class ScalarField(CCShareable):
    def __init__(self, name: str) -> None: ...

    def setName(self, name: str) -> None: ...

    def getName(self) -> str: ...

    @staticmethod
    def NaN() -> ScalarType: ...

    def size(self) -> int: ...

    def computeMeanAndVariance(self) -> None: ...

    @staticmethod
    def ValidValue(value: ScalarType) -> bool: ...

    def flagValueAsInvalid(self, index: int) -> None: ...

    def getMin(self) -> ScalarType: ...

    def getMax(self) -> ScalarType: ...

    def fill(self, value: ScalarType) -> None: ...

    def reserveSafe(self, count: int) -> bool: ...

    def resizeSafe(self, count: int) -> bool: ...

    def getValue(self, index: int) -> ScalarType: ...

    def setValue(self, index: int, value: ScalarType): ...

    def addElement(self, value: ScalarType): ...

    def asArray(self) -> np.ndarray: ...

    def __getitem__(self, index: int) -> ScalarType: ...

    def __setitem__(self, index: int, value: ScalarType) -> None: ...


    def __repr__(self) -> str: ...



# PointClouds

genericPointAction = Callable[[CCVector3, ScalarType], None]


class GenericCloud(ABC):

    @abstractmethod
    def size(self) -> int: ...

    @abstractmethod
    def forEach(self, action: genericPointAction) -> None: ...

    @abstractmethod
    def getBoundingBox(self, bbMin: CCVector3, bbMax: CCVector3) -> None: ...

    def testVisibility(self, P: CCVector3) -> int: ...

    @abstractmethod
    def placeIteratorAtBeginning(self) -> None: ...

    @abstractmethod
    def getNextPoint(self) -> CCVector3: ...

    @abstractmethod
    def enableScalarField(self) -> bool: ...

    @abstractmethod
    def isScalarFieldEnabled(self) -> bool: ...

    @abstractmethod
    def setPointScalarValue(self, pointIndex: int, value: ScalarType) -> None: ...

    @abstractmethod
    def getPointScalarValue(self, pointIndex: int) -> ScalarType: ...


class GenericIndexedCloud(GenericCloud, ABC):
    @overload
    @abstractmethod
    def getPoint(self, index: int) -> CCVector3: ...

    @overload
    @abstractmethod
    def getPoint(self, index: int, P: CCVector3) -> CCVector3: ...


class GenericIndexedCloudPersist(GenericIndexedCloud, ABC):
    @overload
    def getPointPersistentPtr(self, index: int) -> CCVector3: ...


class PointCloudTpl(GenericIndexedCloudPersist):
    def resize(self, newCount: int) -> bool: ...

    def reserve(self, newCount: int) -> bool: ...
    
    def reset(self) -> None: ...

    def invalidateBoundingBox(self) -> None: ...

    def getNumberOfScalarFields(self) -> int: ...

    def getScalarField(self, index: int) -> ScalarField: ...

    def getScalarFieldName(self, index: int) -> str: ...

    def getScalarFieldIndexByName(self, name: str) -> int: ...

    def getCurrentInScalarField(self) -> ScalarField: ...

    def getCurrentOutScalarField(self) -> ScalarField: ...

    def setCurrentInScalarField(self, index: int) -> None: ...

    def getCurrentInScalarFieldIndex(self) -> int: ...

    def setCurrentOutScalarField(self, index: int) -> None: ...

    def getCurrentOutScalarFieldIndex(self) -> int: ...

    def setCurrentScalarField(self, index: int): ...

    def renameScalarField(self, index: int, newName: str) -> bool: ...

    def addScalarField(self, name: str, values: Optional[np.array[PointCoordinateType]] = None) -> int: ...

    def deleteScalarField(self, index: int) -> None: ...

    def deleteAllScalarFields(self, index: int) -> None: ...

    def addPoint(self, point: CCVector3) -> None: ...

    def addPoints(
            self,
            xs: np.array[PointCoordinateType],
            ys: np.array[PointCoordinateType],
            zs: np.array[PointCoordinateType]
    ) -> None: ...

    def __len__(self) -> int: ...


class PointCloud(PointCloudTpl):
    def reserveNormals(self, newCount: int) -> bool: ...

    def addNormal(self, normal: CCVector3) -> None: ...


# Meshes, Triangles


class GenericTriangle(ABC):
    @abstractmethod
    def _getA(self) -> CCVector3: ...

    @abstractmethod
    def _getB(self) -> CCVector3: ...

    @abstractmethod
    def _getC(self) -> CCVector3: ...


genericTriangleAction = Callable[[GenericTriangle], None]


class GenericMesh(GenericTriangle, ABC):
    @abstractmethod
    def size(self) -> int: ...

    @abstractmethod
    def forEach(self, action: genericTriangleAction) -> None: ...

    @abstractmethod
    def getBoundingBox(self, bbMin: CCVector3, bbMax: CCVector3) -> None: ...

    @abstractmethod
    def placeIteratorAtBeginning(self) -> None: ...

    @abstractmethod
    def _getNextTriangle(self) -> GenericTriangle: ...
